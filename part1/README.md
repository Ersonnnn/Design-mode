# 第一部分 基础知识

## 面向对象的 JavaScript

### 动态类型语言和鸭子类型

#### 静态类型语言

- 含义：在编译时就确定了变量的类型
- 优点
  - 在编译时能发现类型不匹配的错误，从而帮助我们提前避免程序运行期间有可能发生的错误
  - 明确规定了数据类型，编译器可以针对这些信息对程序做一些优化，从而提高程序执行速度
- 缺点
  - 迫使程序员依照强契约编写程序
  - 类型的声明会增加更多代码，这些细节让程序员的精力从思考业务逻辑上分散开来。

#### 动态类型语言

- 含义：在程序运行时，待变量被赋予某个值后，才会具有某种类型
- 优点
  - 代码数量少，看起来更简洁，编码更加灵活
  - 程序员可以把精力更多的放在业务逻辑上面
- 缺点
  - 无法保证变量的类型，在程序运行期才会发现跟类型相关的错误
- 对于一个变量，我们可以尝试调用任何对象的任意方法，而无需考虑它原本是否被设计拥有该方法
- 原则（基于鸭子类型的思想）：面向接口编程，而不是面向实现编程

#### 鸭子类型

如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子，映射到 js 中：如果它有这个方法，不管它是不是这个类型，它就能当做这个东西来使用

举例：如果一个对象有 push 和 pop 方法，那么就能当做栈来使用等等

### 多态

- 含义：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果（把做什么和谁去做分开）
- 优点：不必再向对象询问“你是什么类型”而后根据得到的答案调用对象的某个行为，你只管调用该行为就是了，多态机制回为你安排妥当
- 将行为分布在各个对象中，让这些对象各自负责自己的行为，不用管其具体实现，这正是面向对象的优点
- 静态类型语言由于有类型检查的限制，需要通过继承来实现多态
- 动态类型语言由于没有类型检查限制，因此它的多态性是与生俱来的

### 封装

#### 封装数据

- 其他语言中，提供了 private、public、protected 等关键字来提供不同的访问权限
- JavaScript 依赖变量的作用域来模拟 public、private 两种封装性
  - 使用 let 或立即调用函数创建作用域，详细示例见 p12
  - todo：es6 通过 symbol 创建私有属性

#### 封装实现

- 对接口进行封装，即我们无需关注方法的内部实现

#### 封装类型

- 是对于静态类型语言而言的
- 通过抽象类和接口来进行

#### 封装变化

- 找到变化并封装之
- 设计模式的重要体现就是封装变化：当把程序中变化的部分封装好，剩下的就是稳定可复用的部分了（可以理解为设计模式的意义：如何在不重新设计的情况下进行改变。）

### 原型模式和基于原型继承的 JavaScript 对象系统

#### 使用克隆的原型模式

- 是用于创建对象的一种模式：我不关心对象是什么类型，我只是想跟你一样，那我就通过克隆来创建一个一模一样的对象。如果需要一个跟某个对象一模一样的对象，就可以使用原型模式
- 原型模式的实现关键：提供 clone 方法
  - ES5 中提供了 Object.create 方法克隆对象

#### 克隆是创建对象的手段

- 原型模式的目的并非是得到一模一样的对象，而是通过比较便捷的方式去创建某个类型的对象
- 对于 js 来说，其对象系统本身就是使用原型模式来搭建的，因此称之为 原型编程范式 更合适

#### 体验 lo 语言

- 是一个比较老、且也是基于原型的语言

#### 原型编程范型的一些规则

- 一些定义

  - 根对象：由于每个对象都由其他对象克隆而来，那么需要有一个根对象，在 lo 中该对象为 Object
  - 原型：如果 A 对象是从 B 对象克隆而来的，那么 B 对象就是 A 对象的原型。
  - 原型链
    - 定义：A 对象从 B 对象克隆而来，B 对象从 Object 对象克隆而来，那么他们之间就形成了一条原型链。
    - 好处：能够实现“继承”的效果。如果我们尝试调用 A 对象的某个方法，但它本身却没有时，那么 A 对象就会将这个请求委托给它的原型 B 对象，如果 B 对象也没有，接着就会委托给 Object 对象，看起来就好像 B 是 A 的父类，Object 是 B 的父类

- 原型编程范型
  - 所有的数据都是对象
  - 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它
  - 对象会记住它的原型
  - 当对象无法响应某个请求时，会把该请求委托给它自己的原型

#### JavaScript 中的原型继承

- 所有的数据都是对象
  - js 中分为基本类型和对象类型，但除了 undefined 之外，其他的几种基本类型数据都可以通过“包装类”的方式变成对象类型数据，因此可以说 js 中大部分数据都是对象。
  - js 中的根对象是 Object.prototype，这是一个空对象，js 中所有对象都是从该对象克隆而来
    - let obj1 = new Object()
    - let obj2 = {}
  - ps（忽然意识到）：Object 是一个构造器方法
- 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它
  - 无论是通过 new 运算符还是直接声明的对象，js 引擎内部帮我们从根对象上克隆了一个对象出来
  - new 操作符
    - 当使用 new 运算符调用函数时，函数相当于一个构造器
    - 但实际上也是先克隆 Object.prototype 对象，再进行一些其他额外操作
- 对象会记住它的原型
  - 对于 js 来说，是 对象的构造器 有原型，对象会把请求委托给它的构造器的原型
  - js 为每个对象提供了 **proto** 属性，某个对象的 **proto** = 构造器的原型对象（即 obj.**proto** = Constructor.prototype;）
- 当对象无法响应某个请求时，会把该请求委托给它自己的原型
  - js 中每个对象都从 Object.prototype 对象克隆而来
  - 要想实现原型链，我们可以动态设置 构造器的原型，当对象 a 需要借用对象 b 的能力时，可以有选择性地把对象 a 的构造器的原型指向对象 b，从而达到继承的效果
  - 因此 js 中实现继承的方式如图所示
    - undefined

#### 原型继承的未来

- 使用 Object.create() 克隆对象更能体现出原型模式的精髓，如 let obj = Object.create(a)，那么 obj 的原型就是 a。但这种方式创建对象的效率比较低
- 可以通过 Object.create(null) 创建出来的对象是没有原型的对象
- ES6 中 class 语法让 js 看起来像是一门基于类的语言，但其背后仍是通过原型机制来创建对象

## this、call、apply

### this

#### this 的指向

- 作为对象的方法调用
  - this 指向该对象
- 作为普通函数调用
  - this 指向全局对象，在浏览器中，这个全局对象是 window
  - 注意：回调函数中的 this 也指向全局对象。要想在回调里面调用函数里的 this，要么使用箭头函数，要么 let that = this，然后使用 that
- 构造器调用
  - 当用 new 调用函数时，该函数会返回一个对象，this 指向返回的这个对象
  - 需要注意：当构造器显式地返回一个对象时，那我们得到的就是这个对象，而不是上面提到的 this；反之，如果构造器没返回数据或者返回的是非对象类型的数据，就不会造成这个问题
- Function.prototype.call 或 Function.prototype.apply 调用
  - this 指向传入的参数
- with 和 eval

#### 丢失的 this

- 对象中的函数作为对象的方法调用时，指向对象，但是赋值给另一个函数调用时，就是作为普通函数的调用，this 指向全局（老生常谈的知识点了）

### call 和 apply

#### 区别

- 参数
  - 第一个参数：函数体内 this 对象的指向
  - 第二个参数：要传给被调用的函数的参数
    - apply：是一个数组/类数组，将要传给被调用函数的参数用数组进行包裹
    - call：不定个数，直接将第二个往后的参数依次传入函数

#### 作用

- 改变 this 指向
- 模拟 Function.prototype.bind
  - bind 参数同 call，区别是 bind 会返回一个原函数的拷贝，而 apply 和 call 是直接执行方法
- 借用其他对象的方法
  - 示例：在操作类数组对象如 arguments 时，找 Array.prototype 借用方法，比如我们想使用对 arguments 使用 push 方法，就会执行 Array.prototype.push.call(arguments, xx)

## 闭包和高阶函数

### 闭包

#### 变量的作用域

- 函数作用域

#### 变量的生存周期

- 函数内的局部变量随着函数调用的结束而被销毁
- 闭包 —— 当在函数中返回一个函数且这个函数引用了其局部变量时，虽然函数调用结束了，但这个局部变量并没有销毁，其所在的环境还能被外界访问，局部变量的声明看起来被延续了，这就是闭包

#### 闭包的作用

##### 封装变量

- 示例：某函数在调用时，需要一个全局变量去保存一些配置供该函数使用，但这个“全局变量”只有这个函数使用，其他函数不用。那我们就可以把这个“全局变量”封装到函数中，以闭包的方式将这个局部变量变成“全局变量”。

- 详见 chapter1/closure.js 示例代码

##### 延续局部变量的寿命

#### 闭包和面向对象的设计

- 对象以**方法的形式包含了过程**，而闭包则是**在过程中以环境的形式包含了数据**，通常用面向对象思想能实现的功能，用闭包也能实现，反之亦然。

- 详见 chapter1/closure.js 示例代码

#### 用闭包实现命令模式

- 命令模式是把请求封装为对象，从而分离请求的发起者和请求的接受者（执行者）之间的耦合关系

#### 闭包与内存管理

- 闭包可能会造成内存泄露
- 原因：使用闭包时容易形成循环引用（比如在闭包的作用域链中保存一些 DOM 节点）。在 IE 浏览器中，对象的垃圾回收机制采用的是引用计数策略，在引用计数策略中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收。
- 解决方法：把循环引用中的变量设为 null

### 高阶函数

#### 定义

高阶函数是指至少满足下列条件之一的函数

1. 函数可以作为参数被传递
2. 函数可以作为返回值输出

#### 应用场景

##### 函数作为参数传递

- 抽离一部分容易变化的业务逻辑，将这部分业务逻辑放在函数参数中，从而分离业务代码中变化与不变的部分
- 回调函数（详细示例见*chapter1/highOrderFunction.js*）
- Array.prototype.sort
  - 该方法的参数是（封装了数组元素排序规则的）函数

##### 函数作为返回值输出

- 把函数当作返回值输出更能体现出函数式编程的巧妙，这意味着运算过程是可延续的。
- 判断数据类型
- getSingle

#### 高阶函数实现 AOP

##### AOP

- 定义

  - 面向切面编程，主要作用是把一些与核心业务逻辑模块无关的功能抽离出来，如日志统计、安全控制、异常处理等等，再通过“动态织入”的方式掺入业务逻辑模块中。

- 好处

  - 可以保持业务逻辑模块的纯净和高内聚性
  - 可以很方便地服用日志统计等功能模块

- 应用
  - 详见 _chapter1/highOrderFunction.js_ 示例代码
    _【个人理解】_：比如示例代码中，输出 1 和输出 3，是与核心业务逻辑无关的，因此可以将其抽离出来。个人理解其中的关键是“执行原函数”的步骤，将一些逻辑放在“原函数“执行之前或之后，从而实现特殊的功能。
  - 使用 AOP 的方式给函数添加职责，是 js 中一种非常特别和巧妙的**装饰者模式**的实现。

#### 高阶函数的其他应用

##### currying - 函数柯里化

- 定义：currying 又称部分求值。一个 currying 的函数首先会接受一些参数，接受了这些参数之后， 该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。
- 自己对函数柯里化的理解：对参数进行复用，它将一个函数从 f(a, b, c) 转换为 f(a)(b)(c)，在这里，a、b 两个参数就实现了复用。
- 书中对函数柯里化举得例子是保存一些参数，等函数真正被需要求值的时候，之前传入的所有参数都会被一次性用于求值。
- 可以通过 bind 进行函数柯里化
- 日常应用：参数复用的应用会更多一些？
- 柯里化更多可参考博客：<https://juejin.cn/post/6844903882208837645>

##### uncurrying

- 利用 call 和 apply 可以引用不属于该对象的其他对象的方法
- uncurrying 将其他对象的方法提取出来，变成通用的方法
- 个人理解现实中应用的不多

##### 函数节流 —— throttle

##### 分时函数

##### 惰性加载函数

- 适用于在一个函数中，有多个条件分支，但一旦满足某个条件分支，就不可能满足其他条件分支的情况
- 暂时没想到应用场景……个人理解这种情况的实现主要针对于：想省下重复执行的if语句，节省开销，但在实际应用过程中，我们往往会忽略每一个if分支的执行开销。
