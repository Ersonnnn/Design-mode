# 单例模式

## 定义

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

## 应用

有些对象往往只需要一个：线程池、全局缓存、浏览器中的 window 对象、登录浮窗等等。

## 单例模式的实现

### 基本实现

- **用一个变量标志当前是否已经为某个类创建过对象**，如果创建过，则在下一次获取该类的实例时，直接返回之前创建的对象。
- 基本实现：详见[singleton.js 中的 1](./singleton.js)
- 该种方式实现比较简单，但增加了这个类的 **“不透明性”**，即用户在使用这个类时，必须知道这是个单例类，且必须使用 Singleton.getInstance 来获取对象。

### 透明的单例模式

#### 定义

用户使用这个类创建对象时，可以像使用其他任何普通类一样。

#### 实现

- 详见：[singleton.js 中的 2](./singleton.js)
- 缺点：为了把 instance 封装起来，使用了自执行的匿名函数和闭包，并且让这个匿名函数反悔了真正的 Singleton 构造方法，增加了程序的复杂度，阅读起来也不是很舒服。
- 在这段代码中，CreateDiv 的构造函数负责了两件事：
  1. 创建对象和执行初始化 init 方法
  2. 保证只有一个对象
- 当未来想扩展这个类，想将这个类从单例类变成普通类时，必须修改 CreateDiv 构造函数，把控制创建唯一对象那一段去掉，这可能会带来不必要的麻烦。

### 用代理实现单例模式

- 具体实现：详见[singleton.js 中的 3](./singleton.js)
- 通过引入代理类，把负责管理单例的逻辑移到了代理类 proxySingletonCreateDiv 中，这样一来，CreateDiv 就变成了一个普通的类，它跟 proxySingletonCreateDiv 组合起来达到单例模式的效果。

### JavaScript 中的单例模式

- 单例模式的核心是：确保只有一个实例，并提供全局访问
- JavaScript 是一门无类语言（对象不是通过类创建的），因此在 JavaScript 中，可以把 **全局变量** 当作单例来使用。但全局变量很容易造成命名空间污染（被他人覆盖，但使用 const 就不会被覆盖了）。
- 作为开发者，需尽量减少全局变量的使用，如果需要，也要将污染降到最低。降低全局变量带来的命名污染方法：
  - 使用命名空间 —— 不会杜绝全局变量，但可以减少全局变量数量
  - 使用闭包封装私有变量，只暴露一些接口跟外界通信

### 惰性单例

#### 定义

惰性单例指的是在需要的时候才创建对象实例

#### 具体实现

- 详见 [singleton.js 中的 1](./singleton.js) 就是惰性单例的一种实现：在使用时才创建（_基于"类"的单例模式_）
- 在 JavaScript 中，不适合使用基于类的单例模式，下面介绍全局变量结合惰性的单例，代码实现详见[singleton.js 中的 4](./singleton.js)
- 该方法将创建实例对象的职责和管理单例的职责分别放到两个方法中，两个方法可以独立变化且互不影响，当它们连接在一起的时候，就完成了创建唯一实例对象的功能。

## 总结

- 先学习了传统单例模式的实现，又根据 JavaScript 的特性使用了更合适的方法在 JavaScript 中创建单例。
- 代理模式、单一职责原则（将*创建对象*和*单例*的职责分布到两个方法中，将这两个方法组合起来才具有单例模式的威力）
- 单例模式虽然简单，但非常实用，尤其是惰性单例，在合适的时候才创建对象，并且只创建唯一的一个。

## 日常工作中的应用

- 弹窗、通知、toolips 等
- vuex 中的 stores 对象（todo：结合 vuex 源码或许能更好的理解单例模式）