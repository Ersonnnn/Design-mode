# 策略模式

## 定义

*定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。*更详细的解释是：定义一系列的算法，把它们各自封装成策略类，算法被封装在策略类内部的方法里，当客户对Context发起请求时，Context总是把请求委托给这些策略对象中间的某一个进行计算。策略模式的目的是：把**算法的使用**与**算法的实现**分离开来。

从定义上看，策略模式就是用来封装算法的，但在实际开发中，可以把算法的含义扩散开来，使策略模式也可以用来封装一系列的“业务规则”，只要这些业务规则指向的目标一致，并且可以被替换使用，就可以用策略模式来封装他们。

## 策略模式的优点
- 利用组合、委托和多态等技术的思想，有效避免了复杂的条件语句(if-else语句)。
- 策略模式遵循了**开放-封闭原则**，将算法封装在独立的strategy中，使得它们易于切换，易于理解，易于扩展，进而提高代码的**可维护性、扩展性和复用性**。
- 策略模式中的算法可以复用在系统的其他地方，从而避免很多重复的复制粘贴工作。

## 策略模式的缺点
- 会在程序中增加许多策略类或者策略对象（但这也不算缺点，总比把这些逻辑堆砌在Context中要好）；
- 使用策略模式必须了解所有的strategy及各个strategy之间的不同的，才能选择一个合适的strategy，且strategy需要向客户暴露它的所有实现，违反了最少知识原则。

## 实现
一个基于策略模式的程序至少由两部分组成：
- 一组策略类：策略类封装了具体的算法，并负责具体的计算过程；
- 环境类Context：Context接受客户的请求，随后把请求委托给某一个策略类
具体还是看应用举例

## 应用举例
### 使用策略模式计算奖金
- 具体实现：详见[strategy.js 中的 3](./strategy.js)
- 一些个人感想：面对多种 if-else 情况，原来把他们封装起来，然后定义一个统一调用的函数就是策略模式，感觉日常生活中还挺常见的。

## 多态在策略模式中的体现
- 策略模式正是对象多态性的体现：每个策略对象负责的算法被封装在对象内部，我们只需对这些策略对象发出“计算奖金”的请求，就会根据（所传递参数的不同）返回不同的计算结果。

## 使用策略模式实现缓动动画
- 大体思想就是：
  - 定义一组缓动算法（“策略类”），缓动算法接受四个参数：动画已消耗时间、小球原始位置、小球目标位置、动画持续总时间，根据这四个参数，有不同的动画表现形式（如线性移动、渐变等等）
  - 定义一个动画类（策略模式中的“环境类Context”），根据一系列逻辑（具体的不细说了），调用缓动算法。

## 日常工作中的应用
- 表单校验：elementui组件中的form表单，在进行表单验证时，如下图所示，在rules中对每个props进行了配置，书中示意的是通过 validator.add() 为不同字段添加了一系列的校验，个人理解elememtui背后也有类似的add方法，将对象中的这些配置传递到函数中。如书中第81页配置了策略对象，elementui中一样，比如书中的isNonEmpty对象了实际的required等等。
![elementui中的form表单验证示意图](/imgs/elementui-form.png)

## 小结
在JavaScript这种将函数作为一等对象的语言里，策略模式已经融入到了语言本身，我们经常用高阶函数来封装不同的行为，并将它传递到另一个函数中，当对这些函数发出“调用”信息时，不同的函数会返回不同的执行结果。